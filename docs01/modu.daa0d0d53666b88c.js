"use strict";(("undefined"!=typeof self?self:this).webpackChunk_polkadot_apps=("undefined"!=typeof self?self:this).webpackChunk_polkadot_apps||[]).push([[2589],{14534:(e,n,t)=>{t.d(n,{LW:()=>b,vK:()=>k,$y:()=>$,R0:()=>E});var a=t(33403),s=t(90107),o=t(94175);const r=window.ethereum?.isMetaMask,c="npm:@polkagate/snap";let i="0.1.11";const u="polkamask",l={[c]:{version:`>=${i}`}};(async function(e){try{const n=await fetch(`https://registry.npmjs.org/${e}`);if(!n.ok)throw new Error(`Failed to fetch package information. Status: ${n.status}`);return(await n.json())["dist-tags"].latest}catch(e){throw console.error("Error fetching package information:",e.message),e}})(c).then((e=>{i=e,console.log(`Latest version of ${c}: ${e}`)})).catch((e=>{console.error("Failed to get the latest version:",e)}));const m=async e=>{console.info("Args in invokeSnap:",e);const n=e?.snapId||c,t={method:e.method,params:e?.params||[]};return await window.ethereum.request({method:"wallet_invokeSnap",params:{snapId:n,request:t}})},d=async()=>[{address:await m({method:"getAddress"}),name:"Metamask account 1 🍻",type:"sr25519"}],h={accounts:{get:d,subscribe:(()=>{let e=[];return{subscribe:n=>(e.push(n),()=>{e=e.filter((e=>e!==n)),d().then(n).catch(console.error)}),notifySubscribers:n=>{e.forEach((e=>e(n)))}}})().subscribe},metadata:new class{get(){return(async()=>await m({method:"getMetadataList",params:{}}))()}provide(e){return(async e=>await m({method:"setMetadata",params:{metaData:e}}))(e)}},name:u,signer:{signPayload:async e=>await m({method:"signJSON",params:{payload:e}}),signRaw:async e=>await m({method:"signRaw",params:{raw:e}})},version:i},p=async e=>{console.info(`${u} is connecting to ${e} ...`);const n=await(async()=>await window.ethereum.request({method:"wallet_requestSnaps",params:l}))();return{...h,version:n?.[c]?.version}},w={connect:p,enable:p,version:i},f=window;f.injectedWeb3=f.injectedWeb3||{};let b=y(),g=null;function y(){return 0!==Object.values(f.injectedWeb3).filter((({connect:e,enable:n})=>!(!e&&!n))).length}function v(e){throw new Error(`${e}: web3Enable(originName) needs to be called before ${e}`)}function $(e,n=[]){if(!e)throw new Error("You must pass a name for your app to the web3Enable function");const t=n.length?Promise.all(n.map((e=>e().catch((()=>!1))))):Promise.resolve([!0]);var s;return s=()=>t.then((()=>function(e){return r&&(f.injectedWeb3[u]=w),Promise.all(Object.entries(f.injectedWeb3).map((([n,{connect:t,enable:s,version:o}])=>Promise.resolve().then((()=>t?t(e):s?s(e).then((e=>(0,a.Z)({name:n,version:o||"unknown"},e))):Promise.reject(new Error("No connect(..) or enable(...) hook found")))).catch((({message:e})=>{console.error(`Error initializing ${n}: ${e}`)}))))).then((e=>e.filter((e=>!!e))))}(e).then((e=>e.map((e=>(e.accounts.subscribe||(e.accounts.subscribe=n=>(e.accounts.get().then(n).catch(console.error),()=>{})),e))))).catch((()=>[])).then((e=>{const n=e.map((({name:e,version:n})=>`${e}/${n}`));return b=y(),console.info(`web3Enable: Enabled ${e.length} extension${1!==e.length?"s":""}: ${n.join(", ")}`),e})))),g=new Promise((e=>{"complete"===document.readyState?e(s()):window.addEventListener("load",(()=>e(s())))})),g}async function k({accountType:e,extensions:n,genesisHash:t,ss58Format:a}={}){const r=[],c=await async function(e,n){return g?(await g).filter((({name:e})=>!n||n.includes(e))):v(e)}("web3Accounts",n),i=await Promise.all(c.map((async({accounts:n,name:r})=>{try{return function(e,n,t){return n.map((({address:n,genesisHash:a,name:r,type:c})=>({address:42===n.length?n:(0,s.m)((0,o.m)(n),t),meta:{genesisHash:a,name:r,source:e},type:c})))}(r,function(e,n,t){return e.filter((e=>(!e.type||!t||t.includes(e.type))&&(!e.genesisHash||!n||e.genesisHash===n)))}(await n.get(),t,e),a)}catch{return[]}})));return i.forEach((e=>{r.push(...e)})),console.info(`web3Accounts: Found ${r.length} address${1!==r.length?"es":""}`),r}async function E(e){if(!g)return v("web3FromSource");const n=await g,t=e&&n.find((({name:n})=>n===e));if(!t)throw new Error(`web3FromSource: Unable to find an injected ${e}`);return t}}}]);