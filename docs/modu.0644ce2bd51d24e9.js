"use strict";(("undefined"!=typeof self?self:this).webpackChunk_polkadot_apps=("undefined"!=typeof self?self:this).webpackChunk_polkadot_apps||[]).push([[2589],{72542:(e,n,t)=>{t.d(n,{LW:()=>v,vK:()=>I,$y:()=>E,R0:()=>P});var a=t(33403),s=t(90107),r=t(94175);const o={"npm:@polkagate/snap":{name:"polkagate-snap",version:">=0.3.0"}};class i{snapId;constructor(e){this.snapId=e}get(){return d(this.snapId)}provide(e){return p(e,this.snapId)}}const c=async e=>{console.info("args in invoke Snap:",e);const n=e.snapId,t={method:e.method,params:e?.params||[]};return await window.ethereum.request({method:"wallet_invokeSnap",params:{request:t,snapId:n}})},u=e=>async()=>[{address:await c({method:"getAddress",snapId:e}),name:"Metamask account 🍻",type:"sr25519"}],l=e=>async n=>await c({method:"signJSON",params:{payload:n},snapId:e}),m=e=>async n=>await c({method:"signRaw",params:{raw:n},snapId:e}),d=async e=>await c({method:"getMetadataList",params:{},snapId:e}),p=async(e,n)=>await c({method:"setMetadata",params:{metaData:e},snapId:n}),h=e=>()=>{let n=[];return{notifySubscribers:e=>{n.forEach((n=>n(e)))},subscribe:t=>(n.push(t),()=>{n=n.filter((e=>e!==t)),u(e)().then(t).catch(console.error)})}},w=e=>{const{name:n,version:t}=o[e];return{accounts:{get:u(e),subscribe:h(e)().subscribe},metadata:new i(e),name:n,signer:{signPayload:l(e),signRaw:m(e)},version:t}},b=e=>async n=>{const{name:t}=o[e];console.info(`${t} is connecting to ${n} ...`);const a=await(async e=>{const{version:n}=o[e];return await window.ethereum.request({method:"wallet_requestSnaps",params:{[e]:{version:n}}})})(e);if(!a?.[e])throw new Error(`Something went wrong while connecting to the snap:${e}`);return{...w(e),version:a[e]?.version}},f=e=>{const{version:n}=o[e];return{connect:b(e),enable:b(e),version:n}},g=window.ethereum?.isMetaMask,y=window;y.injectedWeb3=y.injectedWeb3||{};let v=j(),$=null;function j(){return 0!==Object.values(y.injectedWeb3).filter((({connect:e,enable:n})=>!(!e&&!n))).length}function k(e){throw new Error(`${e}: web3Enable(originName) needs to be called before ${e}`)}function E(e,n=[]){if(!e)throw new Error("You must pass a name for your app to the web3Enable function");const t=n.length?Promise.all(n.map((e=>e().catch((()=>!1))))):Promise.resolve([!0]);var s;return s=()=>t.then((()=>function(e){const n=["onlysnap","only_snap","snaponly","snap_only"].includes(e.toLowerCase()),t=n?Object.fromEntries(Object.entries(o).map((([e,{name:n}])=>[n,f(e)]))):y.injectedWeb3;return g&&Object.entries(o).map((([e,{name:n}])=>{y.injectedWeb3[n]=f(e)})),n?Promise.all(Object.entries(t).map((([e,{version:n}])=>Promise.resolve().then((()=>(0,a.Z)({name:e,version:n||"unknown"}))).catch((({message:n})=>{console.error(`Error injecting ${e}: ${n}`)}))))).then((e=>e.filter((e=>!!e)))):Promise.all(Object.entries(t).map((([n,{connect:t,enable:s,version:r}])=>Promise.resolve().then((()=>t?t(e):s?s(e).then((e=>(0,a.Z)({name:n,version:r||"unknown"},e))):Promise.reject(new Error("No connect(..) or enable(...) hook found")))).catch((({message:e})=>{console.error(`Error initializing ${n}: ${e}`)}))))).then((e=>e.filter((e=>!!e))))}(e).then((e=>e.map((e=>(e.accounts.subscribe||(e.accounts.subscribe=n=>(e.accounts.get().then(n).catch(console.error),()=>{})),e))))).catch((()=>[])).then((e=>{const n=e.map((({name:e,version:n})=>`${e}/${n}`));return v=j(),console.info(`web3Enable: Enabled ${e.length} extension${1!==e.length?"s":""}: ${n.join(", ")}`),e})))),$=new Promise((e=>{"complete"===document.readyState?e(s()):window.addEventListener("load",(()=>e(s())))})),$}async function I({accountType:e,extensions:n,genesisHash:t,ss58Format:a}={}){const o=[],i=await async function(e,n){return $?(await $).filter((({name:e})=>!n||n.includes(e))):k(e)}("web3Accounts",n),c=await Promise.all(i.map((async({accounts:n,name:o})=>{try{return function(e,n,t){return n.map((({address:n,genesisHash:a,name:o,type:i})=>({address:42===n.length?n:(0,s.m)((0,r.m)(n),t),meta:{genesisHash:a,name:o,source:e},type:i})))}(o,function(e,n,t){return e.filter((e=>(!e.type||!t||t.includes(e.type))&&(!e.genesisHash||!n||e.genesisHash===n)))}(await n.get(),t,e),a)}catch{return[]}})));return c.forEach((e=>{o.push(...e)})),console.info(`web3Accounts: Found ${o.length} address${1!==o.length?"es":""}`),o}async function P(e){if(!$)return k("web3FromSource");const n=await $,t=e&&n.find((({name:n})=>n===e));if(!t)throw new Error(`web3FromSource: Unable to find an injected ${e}`);return t}}}]);