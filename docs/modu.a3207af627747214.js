"use strict";(("undefined"!=typeof self?self:this).webpackChunk_polkadot_apps=("undefined"!=typeof self?self:this).webpackChunk_polkadot_apps||[]).push([[2589],{14534:(e,n,t)=>{t.d(n,{LW:()=>f,vK:()=>k,$y:()=>$,R0:()=>E});var a=t(33403),s=t(90107),o=t(94175);const r="npm:@polkagate/snap",i="0.2.2",c="polkagate-snap",l={[r]:{version:`>=${i}`}},u=async e=>{console.info("Args in invokeSnap:",e);const n=e?.snapId||r,t={method:e.method,params:e?.params||[]};return await window.ethereum.request({method:"wallet_invokeSnap",params:{snapId:n,request:t}})},m=async()=>[{address:await u({method:"getAddress"}),name:"Metamask account 1 🍻",type:"sr25519"}],d={accounts:{get:m,subscribe:(()=>{let e=[];return{subscribe:n=>(e.push(n),()=>{e=e.filter((e=>e!==n)),m().then(n).catch(console.error)}),notifySubscribers:n=>{e.forEach((e=>e(n)))}}})().subscribe},metadata:new class{get(){return(async()=>await u({method:"getMetadataList",params:{}}))()}provide(e){return(async e=>await u({method:"setMetadata",params:{metaData:e}}))(e)}},name:c,signer:{signPayload:async e=>await u({method:"signJSON",params:{payload:e}}),signRaw:async e=>await u({method:"signRaw",params:{raw:e}})},version:i},h=async e=>{console.info(`${c} is connecting to ${e} ...`);const n=await(async()=>await window.ethereum.request({method:"wallet_requestSnaps",params:l}))();return{...d,version:n?.[r]?.version}},p={connect:h,enable:h,version:i},w=window.ethereum?.isMetaMask,b=window;b.injectedWeb3=b.injectedWeb3||{};let f=y(),g=null;function y(){return 0!==Object.values(b.injectedWeb3).filter((({connect:e,enable:n})=>!(!e&&!n))).length}function v(e){throw new Error(`${e}: web3Enable(originName) needs to be called before ${e}`)}function $(e,n=[]){if(!e)throw new Error("You must pass a name for your app to the web3Enable function");const t=n.length?Promise.all(n.map((e=>e().catch((()=>!1))))):Promise.resolve([!0]);var s;return s=()=>t.then((()=>function(e){const n=["onlysnap","only_snap","snaponly","snap_only"].includes(e.toLowerCase()),t=n?{DEFAULT_SNAP_NAME:p}:b.injectedWeb3;return w&&(b.injectedWeb3[c]=p),n?Promise.all(Object.entries(t).map((([e,{version:n}])=>Promise.resolve().then((()=>(0,a.Z)({name:e,version:n||"unknown"}))).catch((({message:n})=>{console.error(`Error injecting ${e}: ${n}`)}))))).then((e=>e.filter((e=>!!e)))):Promise.all(Object.entries(t).map((([n,{connect:t,enable:s,version:o}])=>Promise.resolve().then((()=>t?t(e):s?s(e).then((e=>(0,a.Z)({name:n,version:o||"unknown"},e))):Promise.reject(new Error("No connect(..) or enable(...) hook found")))).catch((({message:e})=>{console.error(`Error initializing ${n}: ${e}`)}))))).then((e=>e.filter((e=>!!e))))}(e).then((e=>e.map((e=>(e.accounts.subscribe||(e.accounts.subscribe=n=>(e.accounts.get().then(n).catch(console.error),()=>{})),e))))).catch((()=>[])).then((e=>{const n=e.map((({name:e,version:n})=>`${e}/${n}`));return f=y(),console.info(`web3Enable: Enabled ${e.length} extension${1!==e.length?"s":""}: ${n.join(", ")}`),e})))),g=new Promise((e=>{"complete"===document.readyState?e(s()):window.addEventListener("load",(()=>e(s())))})),g}async function k({accountType:e,extensions:n,genesisHash:t,ss58Format:a}={}){const r=[],i=await async function(e,n){return g?(await g).filter((({name:e})=>!n||n.includes(e))):v(e)}("web3Accounts",n),c=await Promise.all(i.map((async({accounts:n,name:r})=>{try{return function(e,n,t){return n.map((({address:n,genesisHash:a,name:r,type:i})=>({address:42===n.length?n:(0,s.m)((0,o.m)(n),t),meta:{genesisHash:a,name:r,source:e},type:i})))}(r,function(e,n,t){return e.filter((e=>(!e.type||!t||t.includes(e.type))&&(!e.genesisHash||!n||e.genesisHash===n)))}(await n.get(),t,e),a)}catch{return[]}})));return c.forEach((e=>{r.push(...e)})),console.info(`web3Accounts: Found ${r.length} address${1!==r.length?"es":""}`),r}async function E(e){if(!g)return v("web3FromSource");const n=await g,t=e&&n.find((({name:n})=>n===e));if(!t)throw new Error(`web3FromSource: Unable to find an injected ${e}`);return t}}}]);